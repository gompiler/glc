% Created 2019-03-27 Wed 20:33
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[margin=0.9in]{geometry}
\usepackage[fontsize=10.5pt]{scrextend}
\author{Lore, J., Lougheed D., Wang A.}
\date{\today}
\title{Design Document for Milestone 3}
\hypersetup{
 pdfauthor={Lore, J., Lougheed D., Wang A.},
 pdftitle={Design Document for Milestone 3},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2.2)},
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

This document is for explaining the design decisions we had to make
whilst implementing the components for milestone 3.  \newpage
\section{{\bfseries\sffamily TODO} Language for Code Generation}
\label{sec:org90f4fbd}
We decided on targeting JVM bytecode for our compiler, through the Krakatau
bytecode assembler. Krakatau bytecode syntax is derived from Jasmin, but with
a more modern codebase (written in Python) and some additional features.
TODO: TALK ABOUT ADDITIONAL FEATURES?
\subsection{Advantages}
\label{sec:orgbfbb25b}
The primary advantages of targeting JVM bytecode are:
\hyperref[sec:orge2f0872]{portability}, \hyperref[sec:orgc4babf2]{execution speed},
and (surprisingly to us) its \hyperref[sec:orgeae0f3d]{focus on stack
operations as opposed to a more `straightforward' language}, which
aids in overcoming some of the common pain points of GoLite code
generation:
\subsubsection{Portability}
\label{sec:orge2f0872}
The JVM has been ported to many common platforms, meaning code written in
GoLite, when compiled with our compiler, will be able to run on any
platform the JVM can run on.
\subsubsection{Execution Speed}
\label{sec:orgc4babf2}
Although Java is often considered slow as opposed to ahead-of-time compiled
languages such as C and C++ due to its garbage collection and non-native
compiled code, most implementations of the JVM provide JIT compilation.
By targeting JVM bytecode, we can take advantage of this, and our generated
code will likely be faster than if we generated code in a higher-level
language such as Python.
\subsubsection{{\bfseries\sffamily TODO} Stack Based/Low Level}
\label{sec:orgeae0f3d}
The fact that JVM bytecode is low level gives us lots of granular
control to change the behavior of constructs, especially when
dealing with weird \texttt{GoLite} / \texttt{GoLang} behavior that doesn't
really comply with the more common programming languages. The fact
that it is a stack based language is even more beneficial, since
it makes it easy to account for things like function arguments,
swapping and comparing, whereas a register based language would
require the use of many temporary registers.

\subsection{Disadvantages}
\label{sec:org37bbdd9}
The main disadvantages of generating JVM bytecode are its low-level semantics
and its potentially slow speeds versus an ahead-of-time compiled language,
despite it being faster than other, higher-level languages.
TODO: EXAMPLE OF LOW LEVEL DIFFICULTIES
\section{Semantics}
\label{sec:org5833597}
\subsection{Scoping Rules}
\label{sec:org58ac8cf}
\subsubsection{Go Semantics}
\label{sec:org9843aa6}
In \texttt{GoLite}, new scopes are opened for block statements, \texttt{for}
loops, \texttt{if} / \texttt{else} statements and function declarations (for the
parameters and the function body). A new scope separates
identifiers (which are associated to type maps, variables,
functions and the constants true/false) from the other scopes'
identifiers.

Whenever we refer to an identifier, it will reference the
identifier declared in the closest scope.

There is nothing very special about scoping in \texttt{GoLite}, the main
notable thing is that something like \texttt{var a = a} will refer to \texttt{a}
in a previous scope, not the current \texttt{a} that was just declared,
unlike certain languages like \texttt{C}.
\subsubsection{Mapping Strategy}
\label{sec:orgdc81914}
JVM bytecode, only has ``scoping'' for \texttt{methods}, as they have
their own locals and stack. However, block statements and the
statements inside of them do not have any scopes (except of course
method calls), as we do not have any constructs like loops, if
statements or switch statements. In a higher level language, we
could just append the scope to each identifier to keep them all
unique (this would eliminate the need for separate scopes, as we
already typecheck the correct use of identifiers, but the target
language won't have to do extra work to tie break any
identifiers). In our case, we do a similar strategy. Recall that
in the typecheck phase we generate a new checked AST with
simplified information and assumptions. The identifiers in this
AST also change, where they are tuples that contain the original
identifier and the scope they were declared in. Thus, each scoped
identifier refers to a unique declaration of a scoped identifier.

For our intermediate representation, each scoped identifier will
be converted to an offset of the locals and since each scoped
identifier refers to a unique declaration, then the locals won't
refer to the wrong local.
\subsection{Switch Statements}
\label{sec:org4d6d9e7}
\subsubsection{Go Semantics}
\label{sec:orgf124de0}
In \texttt{GoLite}, \texttt{switch} statements consist of an optional simple
statement, an optional expression and a (potentially empty) list
of case statements, where case statements are either a case with a
non-empty list of expressions with a block statement to execute
when matched or a default case with a block statement. This makes
them structurally different when compared to Java, or \texttt{C} / \texttt{C++}:
\begin{itemize}
\item Simple statements aren't in many languages.
\item Expressions usually aren't optional.
\item Case statements contain a list of expressions, whereas many
languages such as \texttt{Java} only allow a single constant expression.
\end{itemize}
The simple statement is executed before the case checking and
after that the optional expression is compared with each case
statement, evaluating and comparing expression lists from left to
right. The first match enters that case's body, automatically
breaking at the end of it. This makes cases significantly semantically different:
\begin{itemize}
\item Cases automatically break.
\item Each \texttt{case} or \texttt{default} block defines its own scope for declarations.
\item Case statement expressions do not need to be a constant expression.
\end{itemize}

\subsubsection{Mapping Strategy}
\label{sec:orgd85f549}
For the structural differences:
\begin{itemize}
\item Simple statements can be the first statement in the new ``scope''.
\item Any optional expression can be converted to the constant literal `true`.
\item For a list of expressions that is of length greater than one, we
can compare each element from the list one at a time, duping the
element we need to compare for each comparison (as otherwise
we'll lose it).
\end{itemize}
Semantically:
\begin{itemize}
\item To automatically break, for each case statement, we add a \texttt{goto}
to a label at the end of the switch statement.
\item Simulating new scopes is easy because of how our scoping works,
the variable names will already be resolved to their correct local.
\item The expressions not being constants does not matter too much for
us, as we will compare each expression normally (we are
simulating switch statements and aren't limited by the native
switch statement of the language).
\end{itemize}
\subsection{Assignments}
\label{sec:org3c02e8b}
\subsubsection{Go Semantics}
\label{sec:org6cc5766}
In \texttt{GoLite}, assignments are either an assignment operator with a
LHS expression and a RHS expression or just two non empty
expression lists of equal length. This makes them structurally
different (for the two non empty list case) from classic
assignments that either only allow single expressions whether that
be on both sides or only the RHS (assign many expressions to the
same value). However, this structural difference is a lot more
significant than it seems at first glance, because the assignments
are done in a ``simultaneous'' way, that is \texttt{a, b = b, a} will
effectively swap the values of \texttt{a} and \texttt{b}, whereas if the
assignments were done sequentially, \texttt{a} and \texttt{b} would be the
original value of \texttt{b} and wouldn't be swapped.
\subsubsection{Mapping Strategy}
\label{sec:orgd95865c}
There are two tricky things about assignments:
\begin{itemize}
\item Assignment operators. We cannot just convert \texttt{e += e2} to \texttt{e =
      e + e2}, where \texttt{e} is an expression, because \texttt{e} might contain a
function call with side-effects, which we do not want to call
twice (note that in some cases, the assignment operator has an
equivalent instruction, i.e. incrementing and decrementing using
\texttt{iinc}, however we generalize in this discussion as most
operators do not have an equivalent instruction to operate and
assign at the same time). There are thus several cases for \texttt{e}:
\begin{itemize}
\item \texttt{e} is just an identifier, then we can just convert \texttt{e += e2}
to \texttt{e = e + e2}, as there will be no side effects.
\item \texttt{e} is a selector. If \texttt{e} is an addressable selector, then it
is not operating on the direct/anonymous return value of a
function call and so re-evaluating \texttt{e} will not produce any
side effects. Thus we can do \texttt{e = e + e2} again.
\item \texttt{e} is an index, say \texttt{e3[e4]}. In this case, \texttt{e3} can be an
anonymous \texttt{slice} from a function return and \texttt{e4} can also be an
anonymous \texttt{int} from a function return. So in order to avoid
duplicate side effects, we resolve \texttt{e3[e4]} to some base
expression without function calls, storing the result on the
stack, then we operate on the stack, adding \texttt{e2} and then
assigning the result to whatever the stack value references.
\item The other cases for \texttt{e} are not lvalues and shouldn't happen
in the checked AST.
\end{itemize}
\item Assignment of multiple expressions. As mentioned earlier, we
cannot do the assignments sequentially. Thus we evaluate the
entire RHS, pushing each result onto the stack and then
assigning each stack element one by one to their respective LHS
expression. This way \texttt{a, b = b, a} will not overwrite the values
used on the RHS. This is one of the advantages of using a stack
based language, as the stack implicitly acts like temporary
variables, so we don't need to simulate temporary variables for
swapping/simulating simultaneous assignment.
\end{itemize}
\section{{\bfseries\sffamily TODO} Currently Implemented}
\label{sec:org91a8fe8}
The main feature that was worked on during this milestone was the
creation of our intermediate representation and the conversion of
the typechecked AST to said IR.
\end{document}