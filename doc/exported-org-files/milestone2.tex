% Created 2019-03-17 Sun 13:57
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[margin=0.9in]{geometry}
\usepackage[fontsize=10.5pt]{scrextend}
\author{Lore, J., Lougheed D., Wang A.}
\date{\today}
\title{Design Document for Milestone 1}
\hypersetup{
 pdfauthor={Lore, J., Lougheed D., Wang A.},
 pdftitle={Design Document for Milestone 1},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2.2)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

This document is for explaining the design decisions we had to make
whilst implementing the components for milestone 2.
\newpage
\section{Design Decisions}
\label{sec:org3150b70}
\subsection{Symbol Table}
\label{sec:org1b803b0}
TODO
In Haskell, data structures are typically immutable, and much of the language
is designed around this. One of the main design decisions made around the symbol
table was deciding whether to go with an immutable or mutable symbol table. In
an immutable symbol table, a "new" symbol table would have to be made every time
a scope is added or modified. Right away, despite this being a conceptually
better fit for the language, the potential performance degradation of constantly
re-building the symbol table becomes evident.

As a result of this performance impact, we decided on using a mutable symbol
table, with mutability supported via Haskell's 'ST' monad. The trade-off of
this decision was a large increase in the difficulty implementing the symbol
table, which made up a huge portion of the work for this milestone.
TODO
\subsubsection{Scoping Rules}
\label{sec:orgaa742cb}
TODO
\subsection{Type Checker}
\label{sec:org0373b21}
For type-checking, we decided on a single-pass approach which combined symbol
table generation and statement type-checking. This improves performance, and is
possible as a product of GoLite's declaration rules, which specify that
identifiers must be declared before they can be used.
TODO
\subsection{Invalid Programs}
\label{sec:org88f27fe}
Summary of the check in each invalid program:
\begin{itemize}
\item \texttt{append-diff-type.go}: Append an expression of a different type than
the type of the expressions of the \texttt{slice}.
\item \texttt{append-no-slice.go}: Append to something that isn't a slice.
\item \texttt{assign-no-decl.go}: Assign to a variable that hasn't been declared.
\item \texttt{assign-non-addressable.go}: Assign to a LHS that is a
non-addressable field.
\item \texttt{cast-not-base.go}: Cast to a type that isn't a base type.
\item \texttt{dec-non-lval.go}: Decrement something that isn't an \texttt{lvalue}.
\item \texttt{decl-type-mismatch.go}: Declare and assign variable of explicit type
to an expression of a different type.
\item \texttt{float-to-string.go}: Try to cast a \texttt{float} to a \texttt{string}.
\item \texttt{for-no-bool.go}: While variant of for loop with a condition that isn't
a bool.
\item \texttt{func-call.go}: Function call with arguments of different type than
function declaration arguments.
\item \texttt{func-no-decl.go}: Calling a function that hasn't been declared.
\item \texttt{function-already-declared.go}: Trying to declare a function that
has already been declared.
\item \texttt{function-duplicate-param.go}: Trying to declare function with two
params with same name.
\item \texttt{if-bad-init.go}: If with an init statement that does not typecheck
(assignment of different type).
\item \texttt{inc-non-numeric.go}: Increment an expression that doesn't resolve
to a numeric base type.
\item \texttt{index-not-list.go}: Index into something that isn't a slice.
\item \texttt{index.go}: Index that does not resolve to an int.
\item \texttt{invalid-type-decl.go}: Declare a type mapping to a type that
doesn't exist.
\item \texttt{no-field.go}: Using selector operator on struct that doesn't have
the field requested.
\item \texttt{non-existent-assign.go}: Assigning a variable to a non existent
variable.
\item \texttt{non-existent-decl.go}: Trying to declare a variable of a type that
doesn't exist.
\item \texttt{op-assign.go}: Op-assignment where variable and expression are not
compatible with operator (i.e. \texttt{int + string})
\item \texttt{print-non-base.go}: Trying to print a non base type.
\item \texttt{return-expr.go}: Returning an expression of different type than the
return type of the function.
\item \texttt{return.go}: Return nothing from non-void function.
\item \texttt{short-decl-all-decl.go}: Short declaration where all variables on
LHS are already declared.
\item \texttt{short-decl-diff-type.go}: Short declaration where already defined
variables on LHS are not the same type as assigned expression.
\item \texttt{switch-diff-type.go}: Type of expression of case is different from
switch expression type.
\item \texttt{type-already-declared.go}: Trying to define a type mapping to a
type that already exists.
\item \texttt{var-already-declared.go}: Trying to declare a variable that is
already declared.
\end{itemize}
\section{Team}
\label{sec:org0d5d24d}
\subsection{Team Organization}
\label{sec:org3ef4146}
TODO
\subsection{Contributions}
\label{sec:orge2f4965}
\begin{itemize}
\item \textbf{Julian Lore:} TODO
\item \textbf{David Lougheed:} Worked on expression type-checking and type inference,
including tests. Also worked on the weeding pass for return statements.
\item \textbf{Allan Wang:} TODO
\end{itemize}
\end{document}